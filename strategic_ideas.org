* TODO
 - consecutive outputs between growing phases
 - Implement some of the following ideas
    - active density improvement by doing additional work during migration
       - either store potential moves at buckets
       - or go through certain full tables to find potential displacements
 - Improve displaying multiple lines in history and distribution plots
 - improve random walk to rather chose a way to the emptier table

* Definition of Vocabulary

Global Table  or  Distribution Table (gtable)
|---+---+---+---|
|   |   |   |   |
|---+---+---+---|

|---+ +---+ +---+ +---|
|   | |   | |   | |   |
|   | |   | |   | |   |
|   | |   | +---+ +---|
|   | |   |
|---+ +---+
Local Tables  or  Bucket Tables  (ltable)




* THOUGHTS
** 27.10.2016
 - Not actively redistributing already inserted elements is a bad idea!

*** observations:
example: tl 256 | bs 8 | alpha 1.1
|                             | stc inhom | growing | Homogenous Table |
|-----------------------------+-----------+---------+------------------|
| number of larger tables     |        12 |      12 |                  |
|                             |           |         |                  |
| number of displacements     |     14352 |  575840 |                  |
| average displacement length |      2.86 |    9.68 |                  |
| max displacement length     |        20 |     158 |                  |
|                             |           |         |                  |
| max ltable fill degree      |      94.2 |    99.7 |                  |
| min ltable fill degree      |      70.4 |    50.1 |                  |
| median ltable fill degree   |      93.0 |    98.1 |                  |
|-----------------------------+-----------+---------+------------------|

|              |        n | n large |  n disp | avg disp len | max disp len | max ltab fdeg | min ltab fdeg | med ltab fdeg |
|--------------+----------+---------+---------+--------------+--------------+---------------+---------------+---------------|
| static inhom |  1000000 |      12 |   14352 |         2.86 |           20 |          94.2 |          70.4 |          93.0 |
| growing      |  1000000 |      12 |  575840 |         9.68 |          158 |          99.7 |          50.1 |          98.1 |
|              |          |         |         |              |              |               |               |               |
| static inhom | 10000000 |      79 |  330824 |         4.51 |           92 |          98.7 |          82.3 |          98.4 |
| growing      | 10000000 |      79 | 6241160 |        10.39 |          227 |         100.0 |          51.4 |          99.9 |
|              |          |         |         |              |              |               |               |               |
*** provisory explanation
Assume a homogenously filled hash table at 90%.  Now, one local table is grown.
Every local table is filled too 90% except for this one -> 45%.  To recoup this
imbalance it takes 45%*growing table size elements But after around 45% the
table is grown again.  Therefore, to reach a homogenous fill of 90% again,
before growing, all elements have to be inserted into the grown table.  =>
unrealistic much

Too solve this problem, active displacements (without actual insertions have to
be made)

*** solutions?

**** using per bucket information for active redistribution!
when probing a full bucket, if the probed element is not stored there!
remember its key. During migration attract reinsert those elements to the current target bucket
 -> lets assume 70% of buckets have one such element
 -> 35% of buckets have one additional element

** 28.10.2016
CHANGE TEST REPEATED OPERATIONS ON SOMEWHAT FULL TABLE

Fill table up to a point where it just grew, then insert elements until it grows again!
Check these elements!!!
